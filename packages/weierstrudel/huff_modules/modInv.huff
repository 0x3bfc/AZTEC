/**
* @title modinv
* @author Zachary Williamson
*
* @dev MODINV__MAIN computes the modular inverse of a scalar, modulo p, where p = bn128 group modulus
**/

#include "constants.huff"
#include "modInvHelpers.huff"
// compute a modular inverse of a variable 'z', a variable in the finite field of bn128 coordinates
// to do this, we need to exponentiate z by (p-2)
// p-2 = 0x30644E72E131A029B85045B68181585D97816A916871CA8D3C208C16D87CFD45
// this can be broken down into the following bit sequences:
/*
    
    110000
    011
    0010001
    00111
    00111
    0010111
    00001               // nb if we find another '10011' this is worth combining
    0011
    0001101
    0000000101
    0011011
    1
    0000101
    0000010001
    011011
    01101
    00000011
    0000001
    01011
    000010111           // last occurance of '23'
    011                 // last occurance of '3' n.b. (if we find another 11001 can combine this = next sequence)
    001
    01111
    0000001011
    010101
    0010001
    01101
    0000111
    000111              // last occurance of '7'
    0010101         
    0001101             // last occurance of '13'
    001111              // last occurance of '15'
    00001
    0000010001          // last occurance of '17'
    1                   // last occurance of '1'
    000001011           // last occurance of '11'
    011011              // last occurance of '27'
    000011111
    0011111             // last occurance of '31'
    10101               // last occurance of '21'
    000101              // last occurance of '5'
*/

// algorithm can be broken into two steps:
// step 1: use addition chains to create the following variables:
// z 3z 5z 7z 9z 11z 15z 17z 21z 23z 27z 31z
// then, push 48z on the stack (21z+27z)
// step 2: use 'square and multiply' to perform modular exponentiation,
// using the lookup 'table' in step 1 to minimize required multiplications.

// we store our 'lookup table' on the stack to save on gas
// The ordering of the lookup table is as follows:
// 3z 23z 7z 13z 15z 17z z 11z 27z 31z 21z 5z
// this allows us to consume lookup table values in the order of their last occurance

// the general structure of the step 2 is as follows:
// starting stack state:
// t p 3z 23z 7z 13z 15z 17z z 11z 27z 31z 21z 5z
// (t = accumulator variable, p = modulus of bn128 prime field)
// we perform <x> squarings, where <x> is the number of squarings required before
// a multiplication is needed. Because our exponent is fixed, we can hardcode this.
// When a multiplication is required, the required lookup value is either duplicated, or 
// consumed entirely if it is no longer needed


// this is the reverse order of our stack
// 5 21 31 27 11 1 17 15 13 7 23 3 

// we want our actual stack to look like this:
// 3 23 7 13 15 17 1 11 27 31 21 5

// 3z 23z 7z 13z 15z 17z 1z 11z 27z 31z 21z 5z


// we also want 24 - can get from 11 and 13
#define macro INITIALIZE_PRIMES = takes(1) returns(12) {
    P() dup1 dup1 dup1 dup1
    // p p p p p z
    swap5
    // z p p p p p
    dup2 dup1 dup1 dup1 dup1 dup1
}

#define macro CREATE_LOOKUP_ADDITION_CHAIN = takes(0) returns(13) {
    // we want the following stack state:
    // 23z 3z 7z 13z 15z 17z 1z 11z 27z 31z 21z 5z
    // (12 elements)
    // start by pushing 11 instances of 'p' onto the stack, 
    // inserting 'z' into its appropriate position
    INITIALIZE_PRIMES()
    // p p p p p p z p p p p p
    // create 2z and 4z (needed for addition chain)
    dup1 dup8 dup1 mulmod
    // 2z p p p p p p z p p p p p
    dup2 dup2 dup1 mulmod
    // 4z 2z p p p p p p z p p p p p
    dup3 dup10 dup4 mulmod swap4 // (3z)
    // p 4z 2z p 3z p p p p z p p p p p
    dup5 dup4 mulmod swap14 // (5z)
    // p 4z 2z p 3z p p p p z p p p p 5z
    dup15 dup4 mulmod swap5 // (7z)
    // p 4z 2z p 3z 7z p p p z p p p p 5z
    dup6 dup3 mulmod swap10 // (11z)
    
    dup11 dup4 mulmod swap6 // (13z)
    dup7 dup4 mulmod swap7 // (15z)
    dup8 dup4 mulmod swap8 // (17z)
    dup9 dup3 mulmod swap13 // (21z)
    // p 4z 2z p 3z 7z 13z 15z 17z z 11z p p 21z 5
    swap1   // 4z p 2z
    swap2   // 2z p 4z
    dup14 mulmod // 23z 4z p 3z 7z 13z 15z 17z z 11z p p 21z 5
    swap2 // (23z, consume 2z)
    // p 4z 23z 3z 7z 13z 15z 17z z 11z p p 21z 5z
    dup3 dup3 mulmod swap10 // (27z)
    // p 4z 23z 3z 7z 13z 15z 17z z 11z 27z p 21z 5z
    swap1 // 4z p 23z 3z 7z 13z 15z 17z z 11z 27z p 21z 5z
    dup11 mulmod // 31z 23z 3z 7z 13z 15z 17z z 11z 27z p 21z 5z
    swap10 // (31z, consume 4z)
    // p 23z 3z 7z 13z 15z 17z z 11z 27z 31z 21z 5z
    dup1 dup11 dup14 mulmod // (get 48z, the start of our 'main loop')
    // 48z p 23z 3z 7z 13z 15z 17z z 11z 27z 31z 21z 5z
}

// hmm missing some squarings
#define macro MODINV_SQUARE_AND_MULTIPLY = takes(13) returns(0) {
    // starting stack state:
    // t p 23z 3z 7z 13z 15z 17z z 11z 27z 31z 21z 5z
    GET_4_P<dup2>() SQR_3()
    // t p p 23z 3z 7z 13z 15z 17z z 11z 27z 31z 21z 5z
    dup5 mulmod // (need 3z)
    GET_8_P<dup2>() SQR_7() dup9 mulmod // (17z)
    GET_6_P<dup2>() SQR_5() dup6 mulmod // (7z)
    GET_6_P<dup2>() SQR_5() dup6 mulmod // (7z)
    GET_8_P<dup2>() SQR_7() dup4 mulmod // (23z)
    GET_6_P<dup2>() SQR_5() dup10 mulmod // (z)
    GET_5_P<dup2>() SQR_4() dup5 mulmod // (3z)
    GET_8_P<dup2>() SQR_7() dup7 mulmod // (13z)
    GET_11_P<dup2>() SQR_10() dup15 mulmod // (5z)
    GET_8_P<dup2>() SQR_7() dup12 mulmod // (27z)
    GET_2_P<dup2>() SQR_1() dup10 mulmod // (z)
    GET_8_P<dup2>() SQR_7() dup15 mulmod // (5z)
    GET_11_P<dup2>() SQR_10() dup9 mulmod // (17z)
    GET_7_P<dup2>() SQR_6() dup12 mulmod // (27z)
    GET_6_P<dup2>() SQR_5() dup7 mulmod // (13z)
    GET_9_P<dup2>() SQR_8() dup5 mulmod // (3z)
    GET_8_P<dup2>() SQR_7() dup10 mulmod // (z)
    GET_6_P<dup2>() SQR_5() dup11 mulmod // (11z)
    GET_9_P<dup2>() SQR_9()
    // t p 23z 3z 7z 13z 15z 17z z 11z 27z 31z 21z 5z
    // we want to multiply by 23z, and consume 3z as it's no longer needed
    dup2 swap3 mulmod

    GET_3_P<dup2>() SQR_3()
    // t p 3z 7z 13z 15z 17z z 11z 27z 31z 21z 5z
    dup2 swap3 mulmod // (3z, consume it)
    // t p 7z 13z 15z 17z z 11z 27z 31z 21z 5z
    GET_4_P<dup2>() SQR_3() dup8 mulmod // (z) // 115
    GET_6_P<dup2>() SQR_5() dup6 mulmod // (15z)
    GET_11_P<dup2>() SQR_10() dup9 mulmod // (11z)
    GET_7_P<dup2>() SQR_6() dup12 mulmod // (21z)
    GET_8_P<dup2>() SQR_7() dup7 mulmod // (17z)
    GET_6_P<dup2>() SQR_5() dup5 mulmod // (13z)
    GET_8_P<dup2>() SQR_7() dup4 mulmod // (7z) 79
    GET_6_P<dup2>() SQR_6() dup2 swap3 mulmod // (7z, consume)
    // t p 13z 15z 17z z 11z 27z 31z 21z 5z
    GET_8_P<dup2>() SQR_7() dup11 mulmod // (21z)
    GET_7_P<dup2>() SQR_7() dup2 swap3 mulmod // (13z, consume)
    GET_6_P<dup2>() SQR_6() dup2 swap3 mulmod // (15z, consume)
    // t p 17z z 11z 27z 31z 21z 5z
    GET_6_P<dup2>() SQR_5() dup5 mulmod // (z)
    GET_10_P<dup2>() SQR_10() dup2 swap3 mulmod // (17z, consume)
    GET_1_P<dup2>() SQR_1() dup2 swap3 mulmod // (z, consume)
    GET_9_P<dup2>() SQR_9() dup2 swap3 mulmod // (11z, consume)
    GET_6_P<dup2>() SQR_6() dup2 swap3 mulmod // (27z, consume)
    // t p 31z 21z 5z
    GET_10_P<dup2>() SQR_9() dup4 mulmod // (31z)
    GET_7_P<dup2>() SQR_7() dup2 swap3 mulmod // (31z, consume)
    GET_5_P<dup2>() SQR_5() dup2 swap3 mulmod // (21z, consume)
    GET_6_P<dup2>() SQR_6()
    // t p 5z
    swap1 swap2 mulmod // (5z, consume)
    // tadaa. Final stack state: t, our modular inverse
}

#define macro MODINV = takes(0) returns(1) {
    CREATE_LOOKUP_ADDITION_CHAIN()
    MODINV_SQUARE_AND_MULTIPLY()
}

#define macro MODINV__MAIN = takes(0) returns(1) {
    0x00 calldataload MODINV() 0x00 mstore 0x20 0x00 return
}
